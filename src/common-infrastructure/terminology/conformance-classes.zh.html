  <h4>符合性类别</h4>

  <p>本标准描述了 <span w-nodev>用户代理（实现者相关）和</span> 文档
  <span w-nodev> （作者和编写工具的实现者相关）</span> 的符合性标准。</p>

  <p><dfn data-x="Conforming documents">符合规范的文档</dfn> 是符合所有符合性要求的文档。
  为了提高可读性，有些符合性要求是对作者提出的；这些是对文档的隐性要求：
  按照定义所有文档都有对应的作者。（有些情况下，作者本身可能是一个用户代理
  &mdash; 这些用户代理受其他规则的约束，见下文。）
  </p>

  <p class="example">例如，如果一项要求声明 "作者 <!--non-normative-->禁止使用
  <code data-x="">foobar</code> 元素"，意味着文档不允许包含名为 <code data-x="">foobar</code> 的元素。</p>

  <p class="note impl">文档的符合性要求与实现的符合性要求没有隐含的关系。
  用户代理不能随意处理不合规范的文档；不论输入的文档是否合规，本标准中描述的处理模型都适用。</p>

  <p>按照不同的符合性要求，用户代理分为（有重合的）几类。</p>

  <dl>

   <dt id="interactive">Web 浏览器和其他交互式用户代理</dt>

   <dd>

    <p>支持 <span data-x="the XML syntax">XML 语法</span> 的 Web 浏览器必须按照本标准的描述
    处理 XML 文档中 <span data-x="HTML namespace">HTML 命名空间</span> 的元素和属性，
    以便用户与之交互，除非那些元素的语义已经被其他标准覆盖。</p>

    <p class="example">在 XML 文档中查找 <code>script</code> 元素时，符合规范的 Web
    浏览器会执行该元素包含的脚本。然而，如果该元素处于 XSLT 变换中（假设用户代理也支持 XSLT），
    那么处理器会将 <code>script</code> 元素作为组成这一变换的不透明元素处理。</p>

    <p>支持 <span data-x="the HTML syntax">HTML 语法</span> 的 Web 浏览器必须按照本标准的描述
    处理标记为 <span data-x="HTML MIME type">HTML MIME 类型</span> 的文档，以便用户与它们交互。</p>

    <p>支持脚本的用户代理也必须一致地实现本标准中的 IDL 片段，IDL 片段定义在 Web IDL 标准中。 <ref
    spec=WEBIDL></p>

    <p class="note">除非明确声明，覆盖 HTML 元素语义的标准不覆盖对（表示这些元素的） DOM 对象的要求。
    例如，上面例子中的 <code>script</code> 元素仍然实现 <code>HTMLScriptElement</code> 接口。</p>

   </dd>

   <dt id="non-interactive">表示性的非交互式用户代理</dt>

   <dd>

    <p>处理 HTML 和 XML 文档并纯粹地渲染它们的非交互式版本的用户代理必须遵循与
    Web 浏览器同样的符合性规范，除了它们可以免除用户交互的要求。</p>

    <p class="note">非交互式用户代理的典型例子就是打印机（静态 UA）和投影仪（动态 UA）。
    多数静态的非交互式用户代理 <a href="#non-scripted">不支持脚本</a>。</p>

    <p class="example">非交互式的动态 UA 仍然会执行脚本，以便动态提交表单。
    但是因为没有获得焦点的概念，这些 UA 可能不需要实现焦点相关的 DOM API。</p>

   </dd>

   <dt id="renderingUA">支持建议默认渲染的可视化用户代理</dt>

   <dd>

    <p>无论是交互式还是非交互式用户代理，都可以被指定（比如通过作为用户选项）本标准定义的建议默认渲染。</p>

    <p>这并非强制要求，特别是即使用户代理实现了建议默认渲染，也建议为此提供设置来提升用户体验，
    例如改变色彩对比度，使用不同的焦点样式，或者其他提升可访问性和可用性的方式。</p>

    <p>如果指定了建议默认渲染，支持建议默认渲染的用户代理必须根据
    <a href="#rendering">渲染部分</a> 定义的规则实现
    用户代理 <em>期望</em> 实现的行为。</p>

   </dd>

   <dt id="non-scripted">不支持脚本的用户代理</dt>

   <dd>

    <p>不支持脚本的实现（或者完全禁用了其脚本特性的用户代理）可以不支持本标准中提到的事件和 DOM 接口。
    但对于本标准中定义的事件模型和 DOM，这些用户代理仍然必须表现地像支持事件和 DOM 一样。</p>

    <p class="note">脚本可能是构成应用的一部分。不支持脚本或禁用了脚本的 Web 浏览器可能无法完全表达作者的意图。</p>

   </dd>


   <dt>符合性检查器</dt>

   <dd id="conformance-checkers">

    <p>符合性检查器必须验证文档是否符合

    符合性检查程序必须验证文档是否符合本规范中描述的适用的一致性标准。
    自动化的符合检查程序可以不必检测需要解释作者意图的错误（例如，
    <code>blockquote</code> 的内容不是引用文档就不符合标准，如果符合性检查程序在运行时没有人为判断的输入，
    就不必检查 <code>blockquote</code>  元素是否只包含引用的内容）。</p>

    <p>符合性检查器必须检查没有
    <span data-x="concept-document-bc">浏览环境</span>
    （意味着没有脚本运行，并且禁用了解析器的
    <span data-x="scripting flag">脚本标志</span>
    ）时解析输入文档符合规范，
    还应检查在会执行脚本的
    <span data-x="concept-document-bc">浏览环境</span>
    下解析输入文档符合规范，并且脚本的执行永远不会导致不符合规范的状态（脚本执行过程中除外）出现。
    （这只是一个“应该”而不是“必须”的要求，因为这已被证明是不可能的。<ref spec=COMPUTABLE>）</p>

    <p>"HTML 校验器" 可以指代遵循本标准中的适用要求的符合性检查器。</p>

    <div class="note">

     <p>XML DTD 无法表达本标准的所有符合性要求。因此 XML 校验器加 DTD 不能代替符合性检查器。
     此外本标准中定义的这两种写作格式都不属于 SGML，因此 SGML 系统也不能代替符合性检查器。</p>

     <p>换句话说，有三种符合性规则：</p>

     <ol>

      <li>DTD 可表达的规则。</li>

      <li>DTD 不可表达但仍然可以由机器检查的规则。</li>

      <li>只能由人工检查的规则。</li>

     </ol>

     <p>符合性检查器可以检查前面两种。简单的基于 DTD 的校验器只能检查第一类错误，
     因此根据本标准，它不是一种遵循标准的符合性检查器。</p>

    </div>
   </dd>


   <dt>数据挖掘工具</dt>

   <dd id="data-mining">

    <p>不是出于渲染文档或检查文档是否符合规范目的的，处理 HTML 和 XML 文档的应用程序和工具，
    其行为应当与其处理的文档的语义保持一致。</p>

    <p class="example">只增加每个段落（paragraph）的嵌套层级但不增加每个章节（section）的嵌套层级的
    <span data-x="outline">文档大纲</span> 生成工具是不合规范的。</p>

    <p class="comment">只增加 <code data-x="">&lt;p&gt;</code> 的层级而不增加
    <code data-x="">&lt;section&gt;</code> 的层级会破坏 DOM 原有的语义，比如让段落变成了子段落。</p>

   </dd>


   <dt id="editors">编写工具和标记生成器</dt>

   <dd>

    <p>编写工具和标记生成器必须生成 <span data-x="conforming documents">符合规范的文档</span>。
    在适当的地方，适用于作者的符合性规则也适用于编写工具。</p>

    <p>如果编写工具还不能决定作者的意图，可以免除“只能按规定的用途使用元素”的严格要求。
    但是编写工具禁止自动地错误使用元素或鼓励它们的用户这样做。</p>

    <p class="example">例如，将 <code>address</code> 元素用于任意的联系信息是不合规范的；
    该元素只能用于标记文档或章节作者的联系信息。因为编写工具不能区分此意图，所以可以免除这项要求。
    但这不意味着（比如）编写工具可以为了斜体字而任意地使用 <code>address</code> 元素；
    只意味着编写工具可以在用户给章节插入联系信息时不验证它，
    也不需保证用户没用它做别的事或插入别的东西。</p>

    <p class="note">在符合性检查方面，文本编辑器必须像符合性检查器一样输出符合规范的文档。</p>

    <p>当使用编写工具编辑不符合规范的文档时，可以保持未编辑部分的符合性错误。
    （即允许错误的内容经过编辑工具而不发生改变）。
    但如果保持了错误，禁止编写工具声明其输出是符合规范的。</p>

    <p>编写工具大致分为两类：在结构化或语义数据上进行编辑，
    或者在所见即所得的（WYSIWYG）特定媒体上进行编辑。</p>

    <p>前者是编写 HTML 工具的理想机制，因为源码信息中的结构可用于更好地选择 HTML 元素和属性。</p>

    <p>但是 WYSIWYG 工具也是合理的。WYSIWYG 工具应该使用它们认为合适的元素，
    不应该使用它们不确定是否合适的元素。这可能在特定极端情况下意味着对能够使用的流式元素做出限制，
    比如 <code>div</code>，<code>b</code>，<code>i</code>，以及 <code>span</code>，以及使用大量的
    <code data-x="attr-style">style</code> 属性。</p>

    <p>不论是不是 WYSIWYG，所有编写工具都应该尽量让用户创建良构的、语义丰富的、媒体无关的内容。</p>

   </dd>

  </dl>

  <p id="hardwareLimitations">为了防范诸如 DoS 攻击、内存耗尽，或解决平台相关的限制，
  用户代理可能会对本来不受约束的输入强加实现相关的限制。
  <!--INSERT FINGERPRINT-->
  </p>

  <p>为了兼容既有内容与标准，本标准描述了两种写作格式：
  一种基于 <span data-x="the XML syntax">XML</span>，
  另一种基于 SGML 启发的 <a href="#writing">自定义格式</a>
  （称为 <span data-x="the HTML syntax">HTML 语法</span>）。
  本标准鼓励实现同时支持以上两种格式，但至少支持其中一种。</p>

  <p>一些符合性要求称为元素、属性、方法或对象的要求。
  这些要求分为两类：描述内容模型限制的，和描述实现行为的。
  前者是对文档和编写工具的要求，后者是对用户代理的要求。
  类似地，另一些符合性要求称为对作者的要求；这些要求应解释为对作者产出的文档的符合性要求。
  （换句话说，本标准不区分对作者和对文档的符合性要求）</p>

  </div>


