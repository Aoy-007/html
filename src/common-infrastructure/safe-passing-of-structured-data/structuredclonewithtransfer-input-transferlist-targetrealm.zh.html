  <h4 id="structuredclonewithtransfer" data-export="" data-lt="StructuredCloneWithTransfer"
  data-dfn-type="abstract-op"><dfn>StructuredCloneWithTransfer</dfn> ( <var>input</var>,
  <var>transferList</var>, <var>targetRealm</var> )</h4>

  <ol>
   <li>
    <p>令 <var>memory</var> 为一个空的 Map。</p>

    <p class="note"> 与<span>StructuredClone</span> 抽象操作相同，
    <var>memory</var> Map 用来避免多次克隆对象。
    最终的结果是在对象图中保留了环状引用和重复的对象。</p>
   </li>

   <li>
    <p>对<var>transferList</var>中的每一个对象 <var>transferable</var>：

    <ol>
     <li><p>如果 <span>IsTransferable</span>(<var>transferable</var>) 为 false，
     就抛出一个 <span>"<code>DataCloneError</code>"</span> <code>DOMException</code>。</p></li>

     <li><p>令 <var>placeholder</var> 为用户代理定义的占位对象。</p></li>

     <li><p>在 <var>memory</var> 中创建一个入口，以 <var>transferable</var> 为键，以
     <var>placeholder</var>为值。</p></li>
    </ol>
   </li>

   <li><p>令 <var>clone</var> 为 ?
   <span>StructuredClone</span>(<var>input</var>, <var>targetRealm</var>,
   <var>memory</var>)的结果。</p></li>

   <li><p>令 <var>outputTransferList</var> 为一个新的空 <span data-x="js-List">List</span>。</p></li>

   <li>
    <p>对 <var>transferList</var> 中的每个对象 <var>transferable</var>：

    <ol>
     <li><p>令 <var>placeholderResult</var> 为 <var>memory</var> 中键为
     <var>transferable</var>的入口的值。</p></li>

     <li><p>令 <var>transferResult</var> 为 ? <span
     data-x="transfer-abstract-op">Transfer</span>(<var>transferable</var>,
     <var>targetRealm</var>)的结果。</p></li>

     <li>
      <p>在 <var>clone</var> 中，把对 <var>placeholderResult</var> 的引用替换为
      <var>transferResult</var>， 这样曾引用 <var>placeholderResult</var> 的对象
      现在都引用 <var>transferResult</var>。</p>

      <p class="note">这是很少见的 JavaScript 未定义原函数的低层操作。</p>
     </li>

     <li><p>将 <var>transferResult</var> 作为最后一个元素添加到
     <var>outputTransferList</var>。</p></li>
    </ol>
   </li>

   <li><p>返回 { [[Clone]]: <var>clone</var>, [[TransferList]]: <var>outputTransferList</var>
   }。</p></li>
  </ol>

  <p class="note">最初 <span>StructuredCloneWithTransfer</span> 抽象操作被称为"结构化克隆" 算法。
  <span>StructuredClone</span> 抽象操作被称为"内部结构化克隆"算法。
  对象传输算法曾经是 <code>Window</code> 对象上的
  <code data-x="dom-window-postmessage">postMessage()</code> 方法，
  以及 <code>MessagePort</code> 对象上的
  <code data-x="dom-messageport-postmessage">postMessage()</code> 方法的一部分。
  现在对象传输由<span>StructuredCloneWithTransfer</span>抽象操作来处理。</p>


  <span id="structured-clone"></span>
