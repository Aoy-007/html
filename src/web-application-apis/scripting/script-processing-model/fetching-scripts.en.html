  <h5 id="fetching-scripts">Fetching scripts</h5>

  <p>This section introduces a number of algorithms for fetching scripts, taking various necessary
  inputs and resulting in <span data-x="classic script">classic</span> or <span data-x="module
  script">module scripts</span>.</p>

  <hr>

  <p><dfn>Script fetch options</dfn> is a <span>struct</span> with the following <span
  data-x="struct item">items</span>:</p>

  <dl>
   <dt><dfn data-x="concept-script-fetch-options-nonce">cryptographic nonce</dfn></dt>

   <dd><p>The <span data-x="concept-request-nonce-metadata">cryptographic nonce metadata</span> used
   for the initial fetch and for fetching any imported modules</p></dd>

   <dt><dfn data-x="concept-script-fetch-options-integrity">integrity metadata</dfn></dt>

   <dd><p>The <span data-x="concept-request-integrity-metadata">integrity metadata</span> used for
   the initial fetch</dd>

   <dt><dfn data-x="concept-script-fetch-options-parser">parser metadata</dfn></dt>

   <dd><p>The <span data-x="concept-request-parser-metadata">parser metadata</span> used for the
   initial fetch and for fetching any imported modules</p></dd>

   <dt><dfn data-x="concept-script-fetch-options-credentials">credentials mode</dfn></dt>

   <dd><p>The <span data-x="concept-request-credentials-mode">credentials mode</span> used for the
   initial fetch (for <span data-x="module script">module scripts</span>) and for fetching any
   imported modules (for both <span data-x="module script">module scripts</span> and <span
   data-x="classic script">classic scripts</span>)</p></dd>

   <dt><dfn data-x="concept-script-fetch-options-referrer-policy">referrer policy</dfn></dt>

   <dd><p>The <span data-x="concept-request-referrer-policy">referrer policy</span> used for the
   initial fetch and for fetching any imported modules</p></dd>
  </dl>

  <p class="note">Recall that via the <code>import()</code> feature, <span data-x="classic
  script">classic scripts</span> can import <span data-x="module script">module scripts</span>.</p>

  <p>The <dfn>default classic script fetch options</dfn> are a <span>script fetch options</span>
  whose <span data-x="concept-script-fetch-options-nonce">cryptographic nonce</span> is the empty
  string, <span data-x="concept-script-fetch-options-integrity">integrity metadata</span> is the
  empty string, <span data-x="concept-script-fetch-options-parser">parser metadata</span> is "<code
  data-x="">not-parser-inserted</code>", <span
  data-x="concept-script-fetch-options-credentials">credentials mode</span> is "<code
  data-x="">same-origin</code>", and <span
  data-x="concept-script-fetch-options-referrer-policy">referrer policy</span> is the empty
  string.</p>

  <p>Given a <span data-x="concept-request">request</span> <var>request</var> and a <span>script
  fetch options</span> <var>options</var>, we define:</p>

  <dl>
   <dt><dfn>set up the classic script request</dfn></dt>
   <dd><p>Set <var>request</var>'s <span data-x="concept-request-nonce-metadata">cryptographic nonce
   metadata</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-nonce">cryptographic nonce</span>, its <span
   data-x="concept-request-integrity-metadata">integrity metadata</span> to <var>options</var>'s
   <span data-x="concept-script-fetch-options-integrity">integrity metadata</span>, its <span
   data-x="concept-request-parser-metadata">parser metadata</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-parser">parser metadata</span>, and its <span
   data-x="concept-request-referrer-policy">referrer policy</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-referrer-policy">referrer policy</span>.</p></dd>

   <dt><dfn>set up the module script request</dfn></dt>
   <dd><p>Set <var>request</var>'s <span data-x="concept-request-nonce-metadata">cryptographic nonce
   metadata</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-nonce">cryptographic nonce</span>, its <span
   data-x="concept-request-integrity-metadata">integrity metadata</span> to <var>options</var>'s
   <span data-x="concept-script-fetch-options-integrity">integrity metadata</span>, its <span
   data-x="concept-request-parser-metadata">parser metadata</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-parser">parser metadata</span>, its <span
   data-x="concept-request-credentials-mode">credentials mode</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-credentials">credentials mode</span>, and its <span
   data-x="concept-request-referrer-policy">referrer policy</span> to <var>options</var>'s <span
   data-x="concept-script-fetch-options-referrer-policy">referrer policy</span>.</p></dd>
  </dl>

  <p>For any given <span>script fetch options</span> <var>options</var>, the <dfn>descendant script
  fetch options</dfn> are a new <span>script fetch options</span> whose <span data-x="struct
  item">items</span> all have the same values, except for the <span
  data-x="concept-script-fetch-options-integrity">integrity metadata</span>, which is instead the
  empty string.</p>

  <hr>

  <p>The algorithms below can be customized by optionally supplying a custom <dfn
  data-x="fetching-scripts-perform-fetch" export for="fetching scripts">perform the fetch</dfn>
  hook, which takes a <span data-x="concept-request">request</span> and an <dfn export for="fetching
  scripts"><var data-x="fetching-scripts-is-top-level">is top-level</var></dfn> flag. The algorithm
  must complete with a <span data-x="concept-response">response</span> (which may be a <span>network
  error</span>), either synchronously (when using <span>fetch a classic worker-imported
  script</span>) or asynchronously (otherwise). The <var data-x="fetching-scripts-is-top-level">is
  top-level</var> flag will be set for all <span>classic script</span> fetches, and for the initial
  fetch when <span data-x="fetch an external module script graph">fetching an external module script
  graph</span>, <span data-x="fetch a module worker script graph">fetching a module worker script
  graph</span>, or <span data-x="fetch an import() module script graph">fetching an import() module
  script graph</span>, but not for the fetches resulting from <code data-x="">import</code>
  statements encountered throughout the graph.</p>

  <div class="note">
   <p>By default, not supplying the <span data-x="fetching-scripts-perform-fetch">perform the
   fetch</span> will cause the below algorithms to simply <span data-x="concept-fetch">fetch</span>
   the given <span data-x="concept-request">request</span>, with algorithm-specific customizations
   to the <span data-x="concept-request">request</span> and validations of the resulting <span
   data-x="concept-response">response</span>.</p>

   <p>To layer your own customizations on top of these algorithm-specific ones, supply a <span
   data-x="fetching-scripts-perform-fetch">perform the fetch</span> hook that modifies the given
   <span data-x="concept-request">request</span>, <span data-x="concept-fetch">fetches</span> it,
   and then performs specific validations of the resulting <span
   data-x="concept-response">response</span> (completing with a <span>network error</span> if the
   validations fail).</p>

   <p>The hook can also be used to perform more subtle customizations, such as keeping a cache of
   <span data-x="concept-response">responses</span> and avoiding performing a <span
   data-x="concept-fetch">fetch</span> at all.</p>
  </div>

  <p class="note"><cite>Service Workers</cite> is an example of a specification that runs these
  algorithms with its own options for the hook. <ref spec=SW></p>

  <hr>

  <p>Now for the algorithms themselves.</p>

  <p>To <dfn export>fetch a classic script</dfn> given a <var>url</var>, a <var>settings
  object</var>, some <var>options</var>, a <var>CORS setting</var>, and a <var>character
  encoding</var>, run these steps. The algorithm will asynchronously complete with either null (on
  failure) or a new <span>classic script</span> (on success).</p>

  <ol>
   <li><p>Let <var>request</var> be the result of <span data-x="create a potential-CORS
   request">creating a potential-CORS request</span> given <var>url</var>, "<code
   data-x="">script</code>", and <var>CORS setting</var>.</p></li>

   <li><p>Set <var>request</var>'s <span data-x="concept-request-client">client</span> to
   <var>settings object</var>.</p>

   <li><p><span>Set up the classic script request</span> given <var>request</var> and
   <var>options</var>.</p></li>

   <!--FETCH-->
   <li>
    <p>If the caller specified custom steps to <span data-x="fetching-scripts-perform-fetch">perform
    the fetch</span>, perform them on <var>request</var>, with the <var
    data-x="fetching-scripts-is-top-level">is top-level</var> flag set. Return from this algorithm,
    and when the custom <span data-x="fetching-scripts-perform-fetch">perform the fetch</span> steps
    complete with <span data-x="concept-response">response</span> <var>response</var>, run the
    remaining steps.</p>

    <p>Otherwise, <span data-x="concept-fetch">fetch</span> <var>request</var>. Return from this
    algorithm, and run the remaining steps as part of the fetch's <span>process response</span> for
    the <span data-x="concept-response">response</span> <var>response</var>.</p>

    <p class="note"><var>response</var> can be either <span>CORS-same-origin</span> or
    <span>CORS-cross-origin</span>. This only affects how error reporting happens.</p>
   </li>

   <li><p>Set <var>response</var> to <var>response</var>'s <span>unsafe response</span>.</p></li>

   <li>
    <p>If <var>response</var>'s <span data-x="concept-response-type">type</span> is "<code
    data-x="">error</code>", or <var>response</var>'s <span
    data-x="concept-response-status">status</span> is not an <span>ok status</span>, then
    asynchronously complete this algorithm with null, and return.</p>

    <p class="note">For historical reasons, this algorithm does not include MIME type checking,
    unlike the other script-fetching algorithms in this section.</p>
   </li>

   <li><p>If <var>response</var>'s <span data-x="Content-Type">Content Type metadata</span>, if
   any, specifies a character encoding, and the user agent supports that encoding, then set
   <var>character encoding</var> to that encoding (ignoring the passed-in value).</p></li>

   <li>
    <p>Let <var>source text</var> be the result of <span data-x="decode">decoding</span>
    <var>response</var>'s <span data-x="concept-response-body">body</span> to Unicode, using
    <var>character encoding</var> as the fallback encoding.</p>

    <p class="note">The <span>decode</span> algorithm overrides <var>character encoding</var> if
    the file contains a BOM.</p>
   </li>

   <li><p>Let <var>muted errors</var> be true if <var>response</var> was
   <span>CORS-cross-origin</span>, and false otherwise.</p></li>

   <li><p>Let <var>script</var> be the result of <span>creating a classic script</span> given
   <var>source text</var>, <var>settings object</var>, <var>response</var>'s <span
   data-x="concept-response-url">url</span>, <var>options</var>, and <var>muted
   errors</var>.</p></li>

   <li>Asynchronously complete this algorithm with <var>script</var>.</li>
  </ol>

  <p>To <dfn export>fetch a classic worker script</dfn> given a <var>url</var>, a <var>fetch client
  settings object</var>, a <var>destination</var>, and a <var>script settings object</var>, run
  these steps. The algorithm will asynchronously complete with either null (on failure) or a new
  <span>classic script</span> (on success).</p>

  <ol>
   <li><p>Let <var>request</var> be a new <span data-x="concept-request">request</span> whose <span
   data-x="concept-request-url">url</span> is <var>url</var>, <span
   data-x="concept-request-client">client</span> is <var>fetch client settings object</var>, <span
   data-x="concept-request-destination">destination</span> is <var>destination</var>, <span
   data-x="concept-request-mode">mode</span> is "<code data-x="">same-origin</code>", <span
   data-x="concept-request-credentials-mode">credentials mode</span> is "<code
   data-x="">same-origin</code>", <span data-x="concept-request-parser-metadata">parser
   metadata</span> is "<code data-x="">not parser-inserted</code>", and whose
   <span>use-URL-credentials flag</span> is set.</p></li>

   <!--FETCH-->
   <li>
    <p>If the caller specified custom steps to <span data-x="fetching-scripts-perform-fetch">perform
    the fetch</span>, perform them on <var>request</var>, with the <var
    data-x="fetching-scripts-is-top-level">is top-level</var> flag set. Return from this algorithm,
    and when the custom <span data-x="fetching-scripts-perform-fetch">perform the fetch</span> steps
    complete with <span data-x="concept-response">response</span> <var>response</var>, run the
    remaining steps.</p>

    <p>Otherwise, <span data-x="concept-fetch">fetch</span> <var>request</var>. Return from this
    algorithm, and run the remaining steps as part of the fetch's <span>process response</span> for
    the <span data-x="concept-response">response</span> <var>response</var>.</p>
   </li>

   <li><p>Set <var>response</var> to <var>response</var>'s <span>unsafe response</span>.</p></li>

   <li>
    <p>If either of the following conditions are met:</p>

    <ul>
     <li><p><var>response</var>'s <span data-x="concept-response-type">type</span> is "<code
     data-x="">error</code>"; or</p></li>

     <li><p><var>response</var>'s <span data-x="concept-response-status">status</span> is not an
     <span>ok status</span>,</p></li>
    </ul>

    <p>then asynchronously complete this algorithm with null, and return.</p>
   </li>

   <li>
    <p>If both of the following conditions are met:</p>

    <ul>
     <li><p><var>response</var>'s <span data-x="concept-response-url">url</span>'s <span
     data-x="concept-url-scheme">scheme</span> is an <span>HTTP(S) scheme</span>; and</p></li>

     <li><p>the result of <span data-x="extract a MIME type">extracting a MIME type</span> from
     <var>response</var>'s <span data-x="concept-response-header-list">header list</span> is not a
     <span>JavaScript MIME type</span>,</p>
    </ul>

    <p>then asynchronously complete this algorithm with null, and return.</p>

    <p class="note">Other <span data-x="fetch scheme">fetch schemes</span> are exempted from MIME
    type checking for historical web-compatibility reasons. We might be able to tighten this in the
    future; see <a href="https://github.com/whatwg/html/issues/3255">issue #3255</a>.</p>
   </li>

   <li><p>Let <var>source text</var> be the result of <span data-x="UTF-8 decode">UTF-8
   decoding</span> <var>response</var>'s <span data-x="concept-response-body">body</span>.</p></li>

   <li><p>Let <var>script</var> be the result of <span>creating a classic script</span> using
   <var>source text</var>, <var>script settings object</var>, <var>response</var>'s <span
   data-x="concept-response-url">url</span>, and the <span>default classic script fetch
   options</span>.</p></li>

   <li>Asynchronously complete this algorithm with <var>script</var>.</li>
  </ol>

  <p>To <dfn export>fetch a classic worker-imported script</dfn> given a <var>url</var> and a
  <var>settings object</var>, run these steps. The algorithm will synchronously complete with a
  <span>classic script</span> on success, or throw an exception on failure.</p>

  <ol>
   <li><p>Let <var>request</var> be a new <span data-x="concept-request">request</span> whose <span
   data-x="concept-request-url">url</span> is <var>url</var>, <span
   data-x="concept-request-client">client</span> is <var>settings object</var>, <span
   data-x="concept-request-destination">destination</span> is "<code data-x="">script</code>", <span
   data-x="concept-request-parser-metadata">parser metadata</span> is "<code data-x="">not
   parser-inserted</code>", <span>synchronous flag</span> is set, and whose
   <span>use-URL-credentials flag</span> is set.</p></li>

   <li>
    <p>If the caller specified custom steps to <span data-x="fetching-scripts-perform-fetch">perform
    the fetch</span>, perform them on <var>request</var>, with the <var
    data-x="fetching-scripts-is-top-level">is top-level</var> flag set. Let <var>response</var> be
    the result.</p>

    <p>Otherwise, <span data-x="concept-fetch">fetch</span> <var>request</var>, and let
    <var>response</var> be the result.</p>

    <p class="note">Unlike other algorithms in this section, the fetching process is synchronous
    here. Thus any <span data-x="fetching-scripts-perform-fetch">perform the fetch</span> steps will
    also finish their work synchronously.</p>
   </li>

   <li><p>Set <var>response</var> to <var>response</var>'s <span>unsafe response</span>.</p></li>

   <li>
    <p>If any of the following conditions are met:</p>

    <ul>
     <li><p><var>response</var>'s <span data-x="concept-response-type">type</span> is "<code
     data-x="">error</code>"; or</p></li>

     <li><p><var>response</var>'s <span data-x="concept-response-status">status</span> is not an
     <span>ok status</span>; or</p></li>

     <li><p>the result of <span data-x="extract a MIME type">extracting a MIME type</span> from
     <var>response</var>'s <span data-x="concept-response-header-list">header list</span> is not a
     <span>JavaScript MIME type</span>,</p>
    </ul>

    <p>then throw a <span>"<code>NetworkError</code>"</span> <code>DOMException</code>.</p>
   </li>

   <li><p>Let <var>source text</var> be the result of <span data-x="UTF-8 decode">UTF-8
   decoding</span> <var>response</var>'s <span data-x="concept-response-body">body</span>.</p></li>

   <li><p>Let <var>muted errors</var> be true if <var>response</var> was
   <span>CORS-cross-origin</span>, and false otherwise.</p></li>

   <li><p>Let <var>script</var> be the result of <span>creating a classic script</span> given
   <var>source text</var>, <var>settings object</var>, <var>response</var>'s <span
   data-x="concept-response-url">url</span>, the <span>default classic script fetch options</span>,
   and <var>muted errors</var>.</p></li>

   <li><p>Return <var>script</var>.</p></li>
  </ol>

  <p>To <dfn export id="fetch-a-module-script-tree">fetch an external module script graph</dfn>
  given a <var>url</var>, a <var>settings object</var>, and some <var>options</var>, run these
  steps. The algorithm will asynchronously complete with either null (on failure) or a <span>module
  script</span> (on success).</p>

  <ol>
   <li><p><span>Fetch a single module script</span> given <var>url</var>, <var>settings
   object</var>, "<code data-x="">script</code>", <var>options</var>, <var>settings object</var>,
   "<code data-x="">client</code>", and with the <var>top-level module fetch flag</var> set. If the
   caller of this algorithm specified custom <span data-x="fetching-scripts-perform-fetch">perform
   the fetch</span> steps, pass those along as well. Wait until the algorithm asynchronously
   completes with <var>result</var>.</p></li>

   <li><p>If <var>result</var> is null, asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p>Let <var>visited set</var> be « <var>url</var> ».</p></li>

   <li><p><span data-x="fetch the descendants of and link a module script">Fetch the
   descendants of and link</span> <var>result</var> given <var>settings object</var>,
   <var>destination</var>, and <var>visited set</var>. When this asynchronously completes with
   <var>final result</var>, asynchronously complete this algorithm with <var>final
   result</var>.</p></li>
  </ol>

  <p>To <dfn>fetch an import() module script graph</dfn> given a <var>specifier</var>, a <var>base
  URL</var>, a <var>settings object</var>, and some <var>options</var>, run these steps. The
  algorithm will asynchronously complete with either null (on failure) or a <span>module
  script</span> (on success).</p>

  <ol>
   <li><p>Let <var>url</var> be the result of <span data-x="resolve a module specifier">resolving a
   module specifier</span> given <var>base URL</var> and <var>specifier</var>.</p></li>

   <li><p>If <var>url</var> is failure, then asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p><span>Fetch a single module script</span> given <var>url</var>, <var>settings
   object</var>, "<code data-x="">script</code>", <var>options</var>, <var>settings object</var>,
   "<code data-x="">client</code>", and with the <var>top-level module fetch flag</var> set. If the
   caller of this algorithm specified custom <span data-x="fetching-scripts-perform-fetch">perform
   the fetch</span> steps, pass those along as well. Wait until the algorithm asynchronously
   completes with <var>result</var>.</p></li>

   <li><p>If <var>result</var> is null, asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p>Let <var>visited set</var> be « <var>url</var> ».</p></li>

   <li><p><span data-x="fetch the descendants of and link a module script">Fetch the
   descendants of and link</span> <var>result</var> given <var>settings object</var>,
   <var>destination</var>, and <var>visited set</var>. When this asynchronously completes with
   <var>final result</var>, asynchronously complete this algorithm with <var>final
   result</var>.</p></li>
  </ol>

  <p>To <dfn>fetch a modulepreload module script graph</dfn> given a <var>url</var>, a
  <var>destination</var>, a <var>settings object</var>, and some <var>options</var>, run these
  steps. The algorithm will asynchronously complete with either null (on failure) or a <span>module
  script</span> (on success), although it will perform optional steps even after completing.</p>

  <ol>
   <li><p><span>Fetch a single module script</span> given <var>url</var>, <var>settings
   object</var>, <var>destination</var>, <var>options</var>, <var>settings object</var>, "<code
   data-x="">client</code>", and with the <var>top-level module fetch</var> flag set. Wait until
   algorithm asynchronously completes with <var>result</var>.</p></li>

   <li><p>Asynchronously complete this algorithm with <var>result</var>, but do <em>not</em>
   return.</p></li>

   <li>
    <p>If <var>result</var> is not null, optionally perform the following steps:</p>

    <ol>
     <li><p>Let <var>visited set</var> be « <var>url</var> ».</p></li>

     <li><p><span data-x="fetch the descendants of and link a module script">Fetch the
     descendants of and link</span> <var>result</var> given <var>settings object</var>,
     <var>destination</var>, and <var>visited set</var>.</p></li>
    </ol>

    <p class="note">Generally, performing these steps will be beneficial for performance, as it
    allows pre-loading the modules that will invariably be requested later, via algorithms such as
    <span>fetch an external module script graph</span> that fetch the entire graph. However, user
    agents might wish to skip them in bandwidth-constrained situations, or situations where the
    relevant fetches are already in flight.</p>
   </li>
  </ol>

  <p>To <dfn>fetch an inline module script graph</dfn> given a <var>source text</var>, <var>base
  URL</var>, <var>settings object</var>, and <var>options</var>, run these steps. The algorithm will
  asynchronously complete with either null (on failure) or a <span>module script</span> (on
  success).</p>

  <ol>
   <li><p>Let <var>script</var> be the result of <span>creating a module script</span> using
   <var>source text</var>, <var>settings object</var>, <var>base URL</var>, and
   <var>options</var>.</p></li>

   <li><p>If <var>script</var> is null, asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p>Let <var>visited set</var> be an empty <span>set</span>.</p></li>

   <li><p><span data-x="fetch the descendants of and link a module script">Fetch the
   descendants of and link</span> <var>script</var>, given <var>settings object</var>, the
   destination "<code data-x="">script</code>", and <var>visited set</var>. When this asynchronously
   completes with <var>final result</var>, asynchronously complete this algorithm with <var>final
   result</var>.</p></li>
  </ol>

  <p>To <dfn export id="fetch-a-module-worker-script-tree">fetch a module worker script graph</dfn>
  given a <var>url</var>, a <var>fetch client settings object</var>, a <var>destination</var>, a
  <var>credentials mode</var>, and a <var>module map settings object</var>, <span>fetch a
  worklet/module worker script graph</span> given <var>url</var>, <var>fetch client settings
  object</var>, <var>destination</var>, <var>credentials mode</var>, and <var>module map settings
  object</var>, asynchronously completing with the asynchronous completion result of that
  algorithm.</p>

  <p>To <dfn>fetch a worklet script graph</dfn> given a <var>url</var>, a <var>fetch client settings
  object</var>, a <var>destination</var>, a <var>credentials mode</var>, a <var>module map settings
  object</var>, and a <var>module responses map</var>, <span>fetch a worklet/module worker script
  graph</span> given <var>url</var>, <var>fetch client settings object</var>,
  <var>destination</var>, <var>credentials mode</var>, and <var>module map settings object</var>,
  asynchronously completing with the asynchronous completion result of that algorithm. Use the
  following custom steps to <span data-x="fetching-scripts-perform-fetch">perform the fetch</span>
  given <var>response</var>:</p>

  <ol>
   <li><p>Let <var>requestURL</var> be <var>request</var>'s <span
   data-x="concept-request-url">url</span>.</p></li>

   <li><p>If <var>moduleResponsesMap</var>[<var>requestURL</var>] is "<code
   data-x="">fetching</code>", wait <span>in parallel</span> until that entry's value changes, then
   <span>queue a task</span> on the <span>networking task source</span> to proceed with running the
   following steps.</p></li>

   <li><p>If <var>moduleResponsesMap</var>[<var>requestURL</var>] <span data-x="map
   exists">exists</span>, then asynchronously complete the <span
   data-x="fetching-scripts-perform-fetch">perform the fetch</span> steps with
   <var>moduleResponsesMap</var>[<var>requestURL</var>].</p></li>

   <li><p><span data-x="map set">Set</span> <var>moduleResponsesMap</var>[<var>requestURL</var>] to
   "<code data-x="">fetching</code>".</p></li>

   <li>
    <p><span data-x="concept-fetch">Fetch</span> <var>request</var>. To <span>process
    response</span> for the <span data-x="concept-response">response</span> <var>response</var>:</p>

    <ol>
     <li><p>Set <var>moduleResponsesMap</var>[<var>requestURL</var>] to
     <var>response</var>.</p></li>

     <li><p>Asynchronously complete the <span data-x="fetching-scripts-perform-fetch">perform the
     fetch</span> steps with <var>response</var>.</p></li>
    </ol>
   </li>
  </ol>

  <hr>

  <p>The following algorithms are meant for internal use by this specification only as part of <span
  data-x="fetch an external module script graph">fetching an external module script graph</span> or
  other similar concepts above, and should not be used directly by other specifications.</p>

  <p>This diagram illustrates how these algorithms relate to the ones above, as well as to each
  other:</p>

  <svg id="module-script-fetching-diagram" viewBox="0 0 1131 256" style="width: 100%;" role="img" aria-label="Fetch an external module script, fetch an import() module script graph, fetch a modulepreload module script graph, fetch an inline module script graph, and fetch a module worker script graph all call fetch the descendants of and link a module script. It, in turn, calls fetch the descendants of a module script, which then calls the internal module script graph fetching procedure. Finally, the internal module script graph fetching procedure loops back to call fetch the descendants of a module script.">
   <style>
   #module-script-fetching-diagram rect {
    stroke: black;
    fill: transparent;
   }

   #module-script-fetching-diagram path {
    stroke: black;
   }
   #module-script-fetching-diagram path[marker-end] {
    fill: transparent;
   }

   #module-script-fetching-diagram a {
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
   }
   </style>

   <defs>
    <marker id="module-script-fetching-diagram-arrow" orient="auto" markerWidth="6" markerHeight="6" refX="5" refY="3">
     <path d="M0,0 V6 L5,3 Z" fill="black"/>
    </marker>
   </defs>

   <g transform="translate(0.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch an external module script graph</span>
    </foreignObject>
   </g>
   <path d="M90.5,50.5 L470.5,140.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(190.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch an import() module script graph</span>
    </foreignObject>
   </g>
   <path d="M280.5,50.5 L470.5,140.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(380.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch a modulepreload module script graph</span>
    </foreignObject>
   </g>
   <path d="M470.5,50.5 L470.5,140.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(570.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch an inline module script graph</span>
    </foreignObject>
   </g>
   <path d="M660.5,50.5 L470.5,140.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(760.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch a module worker script graph</span>
    </foreignObject>
   </g>
   <path d="M850.5,50.5 L945.5,70.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(950.5,0.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch a worklet script graph</span>
    </foreignObject>
   </g>
   <path d="M1040.5,50.5 L945.5,70.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(855.5,70.5)" class="caller">
    <rect width="180" height="50"/>
    <foreignObject width="180" height="50">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch a worklet/module worker script graph</span>
    </foreignObject>
   </g>
   <path d="M945.5,120.5 L470.5,140.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(260.5,140.5)" class="subalgorithm">
    <rect width="420" height="25"/>
    <foreignObject width="420" height="25">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch the descendants of and link a module script</span>
    </foreignObject>
   </g>
   <path d="M470.5,165.5 L470.5,185.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(260.5,185.5)" class="subalgorithm">
    <rect width="420" height="25"/>
    <foreignObject width="420" height="25">
     <span xmlns="http://www.w3.org/1999/xhtml">fetch the descendants of a module script</span>
    </foreignObject>
   </g>
   <path d="M470.5,210.5 L470.5,230.5" marker-end="url(#module-script-fetching-diagram-arrow)"/>

   <g transform="translate(260.5,230.5)" class="subalgorithm">
    <rect width="420" height="25"/>
    <foreignObject width="420" height="25">
     <span xmlns="http://www.w3.org/1999/xhtml">internal module script graph fetching procedure</span>
    </foreignObject>
   </g>
   <path d="M680.5,242 Q 720,220 680.5,198" marker-end="url(#module-script-fetching-diagram-arrow)"/>
  </svg>

  <p>To <dfn>fetch a worklet/module worker script graph</dfn> given a <var>url</var>, a <var>fetch
  client settings object</var>, a <var>destination</var>, a <var>credentials mode</var>, and a
  <var>module map settings object</var>, run these steps. The algorithm will asynchronously complete
  with either null (on failure) or a <span>module script</span> (on success).</p>

  <ol>
   <li><p>Let <var>options</var> be a <span>script fetch options</span> whose <span
   data-x="concept-script-fetch-options-nonce">cryptographic nonce</span> is the empty string, <span
   data-x="concept-script-fetch-options-integrity">integrity metadata</span> is the empty string,
   <span data-x="concept-script-fetch-options-parser">parser metadata</span> is "<code
   data-x="">not-parser-inserted</code>", <span
   data-x="concept-script-fetch-options-credentials">credentials mode</span> is <var>credentials
   mode</var>, and <span data-x="concept-script-fetch-options-referrer-policy">referrer
   policy</span> is the empty string.</p>

   <li><p><span>Fetch a single module script</span> given <var>url</var>, <var>fetch client settings
   object</var>, <var>destination</var>, <var>options</var>, <var>module map settings object</var>,
   "<code data-x="">client</code>", and with the <var>top-level module fetch flag</var> set. If the
   caller of this algorithm specified custom <span data-x="fetching-scripts-perform-fetch">perform
   the fetch</span> steps, pass those along as well. Wait until the algorithm asynchronously
   completes with <var>result</var>.</p></li>

   <li><p>If <var>result</var> is null, asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p>Let <var>visited set</var> be « <var>url</var> ».</p></li>

   <li><p><span data-x="fetch the descendants of and link a module script">Fetch the
   descendants of and link</span> <var>result</var> given <var>fetch client settings
   object</var>, <var>destination</var>, and <var>visited set</var>. When this asynchronously
   completes with <var>final result</var>, asynchronously complete this algorithm with <var>final
   result</var>.</p></li>
  </ol>

  <p>To <dfn>fetch the descendants of and link a module script</dfn> <var>module
  script</var>, given a <var>fetch client settings object</var>, a <var>destination</var>, and a
  <var>visited set</var>, run these steps. The algorithm will asynchronously complete with either
  null (on failure) or with <var>module script</var> (on success).</p>

  <ol>
   <li><p><span data-x="fetch the descendants of a module script">Fetch the descendants of</span>
   <var>module script</var>, given <var>fetch client settings object</var>, <var>destination</var>,
   and <var>visited set</var>.</p></li>

   <li><p>Return from this algorithm, and run the following steps when <span data-x="fetch the
   descendants of a module script">fetching the descendants of a module script</span> asynchronously
   completes with <var>result</var>.</p></li>

   <li>
    <p>If <var>result</var> is null, then asynchronously complete this algorithm with
    <var>result</var>.</p>

    <p class="note">In this case, there was an error fetching one or more of the descendants. We
    will not attempt to link.</p>
   </li>

   <li><p>Let <var>parse error</var> be the result of <span>finding the first parse error</span>
   given <var>result</var>.</p></li>

   <li><p>If <var>parse error</var> is null, then:</p>

    <ol>
     <li><p>Let <var>record</var> be <var>result</var>'s <span
     data-x="concept-script-record">record</span>.</p></li>

     <li>
      <p>Perform <var>record</var>.<span data-x="js-Link">Link</span>().</p>

      <p class="note">This step will recursively call <span
      data-x="js-Link">Link</span> on all of the module's unlinked dependencies.</p>

      <p>If this throws an exception, set <var>result</var>'s <span
      data-x="concept-script-error-to-rethrow">error to rethrow</span> to that exception.</p>
     </li>
    </ol>
   </li>

   <li><p>Otherwise, set <var>result</var>'s <span data-x="concept-script-error-to-rethrow">error to
   rethrow</span> to <var>parse error</var>.</p></li>

   <li><p>Asynchronously complete this algorithm with <var>result</var>.</p></li>
  </ol>

  <p>To <dfn>fetch the descendants of a module script</dfn> <var>module script</var>, given a
  <var>fetch client settings object</var>, a <var>destination</var>, and a <var>visited set</var>,
  run these steps. The algorithm will asynchronously complete with either null (on failure) or
  with <var>module script</var> (on success).</p>

  <ol>
   <li><p>If <var>module script</var>'s <span data-x="concept-script-record">record</span> is null,
   then asynchronously complete this algorithm with <var>module script</var> and return.</p></li>

   <li><p>Let <var>record</var> be <var>module script</var>'s <span
   data-x="concept-script-record">record</span>.</p></li>

   <li><p>If <var>record</var> is not a <span>Cyclic Module Record</span>, or if
   <var>record</var>.[[RequestedModules]] <span data-x="list is empty">is empty</span>,
   asynchronously complete this algorithm with <var>module script</var>.</p></li>

   <li><p>Let <var>urls</var> be a new empty <span>list</span>.</p></li>

   <li>
    <p><span data-x="list iterate">For each</span> string <var>requested</var> of
    <var>record</var>.[[RequestedModules]],</p>

    <ol>
     <li><p>Let <var>url</var> be the result of <span data-x="resolve a module specifier">resolving
     a module specifier</span> given <var>module script</var>'s <span
     data-x="concept-script-base-url">base URL</span> and <var>requested</var>.</p></li>

     <li><p>Assert: <var>url</var> is never failure, because <span data-x="resolve a module
     specifier">resolving a module specifier</span> must have been <a
     href="#validate-requested-module-specifiers">previously successful</a> with these same two
     arguments.</p></li>

     <li>
      <p>If <var>visited set</var> does not <span data-x="list contains">contain</span>
      <var>url</var>, then:</p>

      <ol>
       <li><p><span data-x="list append">Append</span> <var>url</var> to <var>urls</var>.</p></li>

       <li><p><span data-x="set append">Append</span> <var>url</var> to <var>visited
       set</var>.</p></li>
      </ol>
     </li>
    </ol>
   </li>

   <li><p>Let <var>options</var> be the <span>descendant script fetch options</span> for <var>module
   script</var>'s <span data-x="concept-script-script-fetch-options">fetch options</span>.</p></li>

   <li><p>Assert: <var>options</var> is not null, as <var>module script</var> is a <span>module
   script</span>.</p></li>

   <li>
    <p><span data-x="list iterate">For each</span> <var>url</var> in <var>urls</var>, perform the
    <span>internal module script graph fetching procedure</span> given <var>url</var>, <var>fetch
    client settings object</var>, <var>destination</var>, <var>options</var>, <var>module
    script</var>'s <span>settings object</span>, <var>visited set</var>, and <var>module
    script</var>'s <span data-x="concept-script-base-url">base URL</span>. If the caller of this
    algorithm specified custom <span data-x="fetching-scripts-perform-fetch">perform the
    fetch</span> steps, pass those along while performing the <span>internal module script graph
    fetching procedure</span>.</p>

    <p>These invocations of the <span>internal module script graph fetching procedure</span> should
    be performed in parallel to each other.</p>

    <p>If any of the invocations of the <span>internal module script graph fetching procedure</span>
    asynchronously complete with null, asynchronously complete this algorithm with null, and
    return.</p>

    <p>Otherwise, wait until all of the <span>internal module script graph fetching procedure</span>
    invocations have asynchronously completed. Asynchronously complete this algorithm with
    <var>module script</var>.</p>
   </li>
  </ol>

  <p>To perform the <dfn>internal module script graph fetching procedure</dfn> given a
  <var>url</var>, a <var>fetch client settings object</var>, a <var>destination</var>, some
  <var>options</var>, a <var>module map settings object</var>, a <var>visited set</var>, and a
  <var>referrer</var>, perform these steps. The algorithm will asynchronously complete with either
  null (on failure) or a <span>module script</span> (on success).</p>

  <ol>
   <li><p>Assert: <var>visited set</var> <span data-x="list contains">contains</span>
   <var>url</var>.</p></li>

   <li><p><span>Fetch a single module script</span> given <var>url</var>, <var>fetch client settings
   object</var>, <var>destination</var>, <var>options</var>, <var>module map settings object</var>,
   <var>referrer</var>, and with the <var>top-level module fetch flag</var> unset. If the caller of
   this algorithm specified custom <span data-x="fetching-scripts-perform-fetch">perform the
   fetch</span> steps, pass those along while <span data-x="fetch a single module script">fetching a
   single module script</span>.</p>

   <li><p>Return from this algorithm, and run the following steps when <span data-x="fetch a single
   module script">fetching a single module script</span> asynchronously completes with
   <var>result</var>:</p></li>

   <li><p>If <var>result</var> is null, asynchronously complete this algorithm with null, and
   return.</p></li>

   <li><p><span data-x="fetch the descendants of a module script">Fetch the descendants of</span>
   <var>result</var> given <var>fetch client settings object</var>, <var>destination</var>, and
   <var>visited set</var>.</p></li>

   <li><p>When the appropriate algorithm asynchronously completes with <var>final result</var>,
   asynchronously complete this algorithm with <var>final result</var>.</p></li>
  </ol>

  <p>To <dfn>fetch a single module script</dfn>, given a <var>url</var>, a <var>fetch client
  settings object</var>, a <var>destination</var>, some <var>options</var>, a <var>module map
  settings object</var>, a <var>referrer</var>, and a <var>top-level module fetch</var> flag, run
  these steps. The algorithm will asynchronously complete with either null (on failure) or a
  <span>module script</span> (on success).</p>

  <ol>
   <li><p>Let <var>moduleMap</var> be <var>module map settings object</var>'s <span
   data-x="concept-settings-object-module-map">module map</span>.</p></li>

   <li><p>If <var>moduleMap</var>[<var>url</var>] is "<code data-x="">fetching</code>", wait
   <span>in parallel</span> until that entry's value changes, then <span>queue a task</span> on
   the <span>networking task source</span> to proceed with running the following steps.</p></li>

   <li><p>If <var>moduleMap</var>[<var>url</var>] <span data-x="map exists">exists</span>,
   asynchronously complete this algorithm with <var>moduleMap</var>[<var>url</var>], and
   return.</p></li>

   <li><p><span data-x="map set">Set</span> <var>moduleMap</var>[<var>url</var>] to "<code
   data-x="">fetching</code>".</p>

   <li><p>Let <var>request</var> be a new <span data-x="concept-request">request</span> whose
   <span data-x="concept-request-url">url</span> is <var>url</var>, <span
   data-x="concept-request-destination">destination</span> is <var>destination</var>, <span
   data-x="concept-request-mode">mode</span> is "<code data-x="">cors</code>", <span
   data-x="concept-request-referrer">referrer</span> is <var>referrer</var>, and <span
   data-x="concept-request-client">client</span> is <var>fetch client settings
   object</var>.</p></li>

   <li><p>If <var>destination</var> is "<code data-x="">worker</code>" or "<code
   data-x="">sharedworker</code>" and the <var>top-level module fetch</var> flag is set, then set
   <var>request</var>'s <span data-x="concept-request-mode">mode</span> to "<code
   data-x="">same-origin</code>".

   <li><p><span>Set up the module script request</span> given <var>request</var> and
   <var>options</var>.</p></li>

   <!--FETCH-->
   <li>
    <p>If the caller specified custom steps to <span data-x="fetching-scripts-perform-fetch">perform
    the fetch</span>, perform them on <var>request</var>, setting the <var
    data-x="fetching-scripts-is-top-level">is top-level</var> flag if the <var>top-level module
    fetch</var> flag is set. Return from this algorithm, and when the custom <span
    data-x="fetching-scripts-perform-fetch">perform the fetch</span> steps complete with <span
    data-x="concept-response">response</span> <var>response</var>, run the remaining steps.</p>

    <p>Otherwise, <span data-x="concept-fetch">fetch</span> <var>request</var>. Return from this
    algorithm, and run the remaining steps as part of the fetch's <span>process response</span> for
    the <span data-x="concept-response">response</span> <var>response</var>.</p>

    <p class="note"><var>response</var> is always <span>CORS-same-origin</span>.</p>
   </li>

   <li>
    <p>If any of the following conditions are met:</p>

    <ul>
     <li><p><var>response</var>'s <span data-x="concept-response-type">type</span> is "<code
     data-x="">error</code>"; or</p></li>

     <li><p><var>response</var>'s <span data-x="concept-response-status">status</span> is not an
     <span>ok status</span>; or</p></li>

     <li><p>the result of <span data-x="extract a MIME type">extracting a MIME type</span> from
     <var>response</var>'s <span data-x="concept-response-header-list">header list</span> is not a
     <span>JavaScript MIME type</span>,</p></li>
    </ul>

    <p>then <span data-x="map set">set</span> <var>moduleMap</var>[<var>url</var>] to null,
    asynchronously complete this algorithm with null, and return.</p>
   </li>

   <li><p>Let <var>source text</var> be the result of <span data-x="UTF-8 decode">UTF-8
   decoding</span> <var>response</var>'s <span data-x="concept-response-body">body</span>.</p></li>

   <li><p>Let <var>module script</var> be the result of <span>creating a module script</span> given
   <var>source text</var>, <var>module map settings object</var>, <var>response</var>'s <span
   data-x="concept-response-url">url</span>, and <var>options</var>.</p></li>

   <li>
    <p><span data-x="map set">Set</span> <var>moduleMap</var>[<var>url</var>] to <var>module
    script</var>, and asynchronously complete this algorithm with <var>module script</var>.</p>

    <p class="note">It is intentional that the <span>module map</span> is keyed by the <span
    data-x="concept-request-url">request URL</span>, whereas the <span
    data-x="concept-script-base-url">base URL</span> for the <span>module script</span> is
    set to the <span data-x="concept-response-url">response URL</span>. The former is used to
    deduplicate fetches, while the latter is used for URL resolution.</p>
   </li>
  </ol>

  <p>To <dfn data-x="finding the first parse error">find the first parse error</dfn> given a root
  <var>moduleScript</var> and an optional <var>discoveredSet</var>:</p>

  <ol>
   <li><p>Let <var>moduleMap</var> be <var>moduleScript</var>'s <span>settings object</span>'s
   <span data-x="concept-settings-object-module-map">module map</span>.</p></li>

   <li><p>If <var>discoveredSet</var> was not given, let it be an empty <span>set</span>.</p></li>

   <li><p><span data-x="list append">Append</span> <var>moduleScript</var> to
   <var>discoveredSet</var>.</p></li>

   <li><p>If <var>moduleScript</var>'s <span data-x="concept-script-record">record</span> is null,
   then return <var>moduleScript</var>'s <span data-x="concept-script-parse-error">parse
   error</span>.</p></li>

   <li><p>Let <var>childSpecifiers</var> be the value of <var>moduleScript</var>'s <span
   data-x="concept-script-record">record</span>'s [[RequestedModules]] internal slot.</p></li>

   <li><p>Let <var>childURLs</var> be the <span>list</span> obtained by calling
   <span>resolve a module specifier</span> once for each item of <var>childSpecifiers</var>, given
   <var>moduleScript</var>'s <span data-x="concept-script-base-url">base URL</span> and that item.
   (None of these will ever fail, as otherwise <var>moduleScript</var> would have been <a
   href="#validate-requested-module-specifiers">marked as itself having a parse error</a>.)</p></li>

   <li><p>Let <var>childModules</var> be the <span>list</span> obtained by <span
   data-x="map get">getting each value</span> in <var>moduleMap</var> whose key is given by an
   item of <var>childURLs</var>.</p></li>

   <li>
    <p><span data-x="list iterate">For each</span> <var>childModule</var> of
    <var>childModules</var>:</p>

    <ol>
     <li><p>Assert: <var>childModule</var> is a <span>module script</span> (i.e., it is not "<code
     data-x="">fetching</code>" or null); by now all <span data-x="module script">module
     scripts</span> in the graph rooted at <var>moduleScript</var> will have successfully been
     fetched.</p></li>

     <li><p>If <var>discoveredSet</var> already <span data-x="list contains">contains</span>
     <var>childModule</var>, <span>continue</span>.</p></li>

     <li><p>Let <var>childParseError</var> be the result of <span>finding the first parse
     error</span> given <var>childModule</var> and <var>discoveredSet</var>.</p></li>

     <li><p>If <var>childParseError</var> is not null, return <var>childParseError</var>.</p></li>
    </ol>
   </li>

   <li><p>Return null.</p></li>
  </ol>

