  <h6 id="Best practices">最佳实践</h6>

  <p>如果画布可交互，作者应该对画布的每个可聚焦部分，都在该元素的 fallback 内容中包含一个可聚焦元素，
  像 <a href="#drawCustomFocusRingExample">上述例子</a> 中那样。</p>

  <p>当渲染焦点环时，为了确保焦点环的外观和原生焦点环相同，作者应该使用 <code
  data-x="dom-context-2d-drawFocusIfNeeded">drawFocusIfNeeded()</code> 方法，
  把需要绘制焦点环的元素传给它。该方法只在元素 <span data-x="focused">获得焦点</span>
  时才绘制焦点环。这样就可以在每次绘制元素时简单地调用它，而不需要先检查元素是否已经获得焦点。</p>

  <p>除了绘制焦点环以外，作者还应该在画布中的元素获得焦点时调用 <code
  data-x="dom-context-2d-scrollPathIntoView">scrollPathIntoView()</code> 方法，
  以确保它在屏幕上可见（如果可以的话）。</p>

  <p id="no-text-editing-in-canvas-please">作者应该避免使用 <code>canvas</code> 元素
  实现文本编辑控件，这样做有很多缺点：</p>

  <ul>

   <li>必须重新实现鼠标移动光标位置。</li>

   <li>必须重新实现键盘移动光标位置（对于多行文本输入可能会跨行）</li>

   <li>必须重新实现文本控件的滚动。（很长的行会横向滚动，多行输入会纵向滚动）</li>

   <li>必须重新实现拷贝粘贴这样的原生特性。</li>

   <li>必须重新实现拼写检查这样的原生特性。</li>

   <li>必须重新实现拖放这样的原生特性。</li>

   <li>必须重新实现页面范围内文本搜索这样的原生特性。</li>

   <li>必须重新实现用户特定的一些原生特性，例如自定义文本服务。
   由于不同用户可能安装有不同的服务，而且可能有无限种这样的服务，基本不可能实现这些特性。</li>

   <li>必须重新实现双向文本编辑。</li>

   <li>对多行文本编辑，必须为相关语言重新实现折行。</li>

   <li>必须重新实现文本选择。</li>

   <li>必须重新实现双向文本选区的拖动。</li>

   <li>必须重新实现平台原生的键盘快捷键。</li>

   <li>必须重新实现平台原生的输入法编辑器(IMEs)。</li>

   <li>必须重新实现撤销和重做功能。</li>

   <li>必须重新实现可访问性特性，比如跟随光标或选区放大。</li>

  </ul>

  <p>这是巨大的工作量，而且强烈建议作者避免做任何这些事情，不如直接使用
  <code>input</code> 元素， <code>textarea</code> 元素，或者
  <code data-x="attr-contenteditable">contenteditable</code> 属性。</p>


